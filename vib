#!/usr/bin/env python3
import sys
from html.parser import HTMLParser

def attr2url(attr):
	attr = attr.replace(' ', '')
	if attr.startswith('https://') or attr.startswith('http://') or attr.startswith('//'):
		return f'{attr.split("//", maxsplit=1)[1]}'
	return f'{urls[0]}{attr}' if attr.startswith('/') else f'{urls[1]}/{attr}'

class ViB(HTMLParser):
	bad = {'script': False, 'style': False}
	form = ['', '']
	input_tags = ['input', 'textarea', 'select', 'button']

	def handle_starttag(self, tag, attrs):
		attrs = dict(attrs)
		if tag == 'a' and 'href' in attrs.keys():
			sys.stdout.write(f'\033{len(urls)}\035 ')
			urls.append(attr2url(attrs['href']))
		elif tag == 'form':
			ViB.form[0] = f'{attr2url(attrs.get("action", ""))} '
			ViB.form[1] = attrs.get('method', 'get')
		elif tag in ViB.input_tags and 'name' in attrs.keys():
			ViB.form[0] += f'{attrs["name"]}={attrs.get("value", "")}&'
		elif tag in ViB.bad.keys():
			ViB.bad[tag] = True

	def handle_endtag(self, tag):
		if tag in ViB.bad.keys():
			ViB.bad[tag] = False
		elif tag == 'form' and ViB.form[0] != ' ':
			print(f'\033{len(urls)}\035 {ViB.form[0].split(" ")[0]} {ViB.form[1]}')
			urls.append(f'{ViB.form[0][:-1]}')

	def handle_data(self, data):
		if not (True in ViB.bad.values()) and not data.isspace():
			print(data.strip())

parser = ViB()
sys.stdin.reconfigure(errors='ignore')
input = sys.stdin.readlines()
urls = []
curr = input[-1].split('://', maxsplit=1)[1]
urls.append(curr.split('/', maxsplit=1)[0])
urls.append(curr.rsplit('/', maxsplit=1)[0])
parser.feed('\n'.join(input[:-1]))
for i in range(len(urls) - 1, 1, -1):
	print(urls[i])
print(curr)
